pipeline {
  agent any
  options {
    timestamps()
    disableConcurrentBuilds()
  }

  parameters {
    booleanParam(name: 'CLEAN_BUILD', defaultValue: true, description: 'Clean build (remove node_modules/dist)')
  }

  environment {
    // GitHub
    GIT_REPO_URL       = 'https://github.com/NRKim93/1rmCal_BE.git'
    GIT_BRANCH         = 'main'
    GIT_CREDENTIALS_ID = 'github-pat-jenkins'

    // Build output
    ARTIFACT_NAME = 'deploy_bundle.tar.gz'

    // UMPC target
    UMPC_HOST     = '172.30.1.24'
    REMOTE_TMP    = 'C:/temp/onerm-backend'
    UMPC_APP_DIR  = 'C:/apps/onerm-backend'
    UMPC_APP_NAME = 'onerm-backend'
    APP_PORT      = '3001'
    SMOKE_PATH    = '/'

    // Jenkins SSH credential id
    UMPC_SSH_CRED_ID = 'umpc-ssh-key'

    // Jenkins "Secret file" credential id that contains the backend .env
    ENV_FILE_CRED_ID = 'onerm-backend-env'
  }

  stages {

    stage('Clean Workspace') {
      steps { cleanWs disableDeferredWipeout: true }
    }

    stage('Checkout Source (GitHub)') {
      steps {
        echo "Checkout: ${env.GIT_REPO_URL} (${env.GIT_BRANCH})"
        checkout([
          $class: 'GitSCM',
          branches: [[name: "*/${env.GIT_BRANCH}"]],
          userRemoteConfigs: [[url: env.GIT_REPO_URL, credentialsId: env.GIT_CREDENTIALS_ID]]
        ])
      }
    }

    stage('Install & Build NestJS (Windows)') {
      steps {
        powershell """
          \$ErrorActionPreference = 'Stop'
          chcp 65001 | Out-Null
          [Console]::OutputEncoding = [Text.Encoding]::UTF8

          # ✅ parameter에서 안전하게 읽기 (env로 읽지 말 것)
          \$cleanBuild = [System.Convert]::ToBoolean('${params.CLEAN_BUILD}')
          if (\$cleanBuild) {
            Write-Host 'CLEAN_BUILD enabled'
            foreach (\$p in @('node_modules', 'dist')) {
              if (Test-Path \$p) { Remove-Item -Recurse -Force \$p }
            }

            # TypeScript incremental cache can cause missing emits when dist is wiped.
            Get-ChildItem -Force -Filter '*.tsbuildinfo' -ErrorAction SilentlyContinue | ForEach-Object {
              try { Remove-Item -Force -ErrorAction SilentlyContinue -LiteralPath \$_.FullName } catch { }
            }
          }

          node -v
          npm -v
          npm ci
          npx prisma generate
          npm run build

          if (!(Test-Path 'dist\\main.js')) { throw 'Missing dist\\main.js' }
          if (!(Test-Path 'dist\\app.module.js')) { throw 'Missing dist\\app.module.js' }
          if (!(Test-Path 'dist\\domain\\users\\service\\oauth.service.js')) { throw 'Missing dist\\domain\\users\\service\\oauth.service.js' }
        """
      }
    }

    stage('Package Artifact (Windows)') {
      steps {
        powershell """
          \$ErrorActionPreference = 'Stop'
          chcp 65001 | Out-Null
          [Console]::OutputEncoding = [Text.Encoding]::UTF8

          # keep only production deps in node_modules
          npm prune --omit=dev

          Remove-Item -Recurse -Force 'deploy_bundle' -ErrorAction SilentlyContinue
          New-Item -ItemType Directory -Force -Path 'deploy_bundle' | Out-Null

          if (!(Test-Path 'dist\\main.js')) { throw 'Missing dist\\main.js' }
          if (!(Test-Path 'node_modules'))  { throw 'Missing node_modules' }

          New-Item -ItemType Directory -Force -Path 'deploy_bundle\\dist' | Out-Null
          Copy-Item -Recurse -Force 'dist\\*' 'deploy_bundle\\dist\\'

          New-Item -ItemType Directory -Force -Path 'deploy_bundle\\node_modules' | Out-Null
          Copy-Item -Recurse -Force 'node_modules\\*' 'deploy_bundle\\node_modules\\'
          Copy-Item -Force          'package.json' 'deploy_bundle\\package.json'
          if (Test-Path 'package-lock.json') { Copy-Item -Force 'package-lock.json' 'deploy_bundle\\package-lock.json' }
          if (Test-Path 'prisma') {
            New-Item -ItemType Directory -Force -Path 'deploy_bundle\\prisma' | Out-Null
            Copy-Item -Recurse -Force 'prisma\\*' 'deploy_bundle\\prisma\\'
          }

          # ecosystem file
          \$ecosystem = @"
module.exports = {
  apps: [{
    name: '${env.UMPC_APP_NAME}',
    script: 'dist/main.js',
    env: {
      NODE_ENV: 'production',
      PORT: '${env.APP_PORT}'
    }
  }]
}
"@
          \$ecosystem | Out-File -FilePath 'deploy_bundle\\ecosystem.config.cjs' -Encoding utf8 -Force

          # pack
          Remove-Item -Force '${env.ARTIFACT_NAME}' -ErrorAction SilentlyContinue
          tar -czf '${env.ARTIFACT_NAME}' -C deploy_bundle .

          if (!(Test-Path '${env.ARTIFACT_NAME}')) { throw 'Artifact not created' }
          Get-Item '${env.ARTIFACT_NAME}' | Format-List Name,Length,LastWriteTime
        """
      }
    }

    stage('Deploy to UMPC over SSH') {
      steps {
        withCredentials([
          sshUserPrivateKey(
            credentialsId: "${env.UMPC_SSH_CRED_ID}",
            keyFileVariable: 'SSH_KEY',
            usernameVariable: 'SSH_USER'
          ),
          file(credentialsId: "${env.ENV_FILE_CRED_ID}", variable: 'ENV_FILE')
        ]) {
          powershell '''
            $ErrorActionPreference = 'Stop'
            chcp 65001 | Out-Null
            [Console]::OutputEncoding = [Text.Encoding]::UTF8

            # 디버그: env 값 확인
            Write-Host ("ENV_UMPC_HOST_RAW=[" + $env:UMPC_HOST + "]")

            # --- raw values (문자열 강제) ---
            $keyRaw  = [string]$env:SSH_KEY
            $userRaw = [string]$env:SSH_USER
            $hostRaw = [string]$env:UMPC_HOST

            # --- sanitize (PS 5.1 호환) ---
            $key       = ('' + $keyRaw ).Trim().Trim('[',']','"')
            $user      = ('' + $userRaw).Trim().Trim('[',']','"')
            $umpcHost  = ('' + $hostRaw).Trim().Trim('[',']','"')   # ✅ $Host 예약어 절대 안 씀

            if ([string]::IsNullOrWhiteSpace($user))     { throw "SSH_USER is empty" }
            if ([string]::IsNullOrWhiteSpace($umpcHost)) { throw "UMPC_HOST is empty" }
            if ([string]::IsNullOrWhiteSpace($key))      { throw "SSH_KEY is empty" }

            if (!(Test-Path $key)) {
              throw "SSH key file not found: [$key]"
            }

            # OpenSSH (Windows) rejects keys with permissive ACLs (UNPROTECTED PRIVATE KEY FILE).
            # Jenkins writes credentials to a temp file that can be "too open", so copy + lock it down.
            $keySecure = $null
            $envFileSecure = $null
            $keySecure = Join-Path $env:TEMP ("jenkins_sshkey_" + ([guid]::NewGuid().ToString('N')))
            Copy-Item -Force -LiteralPath $key -Destination $keySecure
            try {
              $who = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
              & icacls $keySecure /inheritance:r | Out-Null
              & icacls $keySecure /grant:r "${who}:(R)" "SYSTEM:(R)" "BUILTIN\\Administrators:(R)" | Out-Null
            } catch {
              throw "Failed to secure SSH key ACLs: $($_.Exception.Message)"
            }
            $key = $keySecure

            $remoteTmp = [string]$env:REMOTE_TMP
            $appDir    = [string]$env:UMPC_APP_DIR
            $appName   = [string]$env:UMPC_APP_NAME
            $port      = [string]$env:APP_PORT
            $artifact  = [string]$env:ARTIFACT_NAME
            $envFile   = [string]$env:ENV_FILE

            $dest = ("{0}@{1}" -f $user, $umpcHost).Trim()
            $remoteTgz = "$remoteTmp/$artifact"
            $remoteEnv = "$remoteTmp/.env"

            Write-Host "SSH_USER=[$user]"
            Write-Host "UMPC_HOST=[$umpcHost]"
            Write-Host "DEST=[$dest]"
            Write-Host "SSH_KEY=[****]"
            Write-Host "ENV_FILE=[****]"

            function Run-External([string]$exe, [object[]]$arguments) {
              $prevEap = $ErrorActionPreference
              $ErrorActionPreference = 'Continue'
              # exe 존재 확인 (PATH 문제면 여기서 바로 잡힘)
              $cmd = Get-Command $exe -ErrorAction SilentlyContinue
              if (-not $cmd) {
                throw "Executable not found in PATH: [$exe]  (try full path like C:\\Windows\\System32\\OpenSSH\\ssh.exe)"
              }

              # 로그 출력(PS5.1 안전)
              $printed = ""
              foreach ($a in $arguments) { $printed += "[$a] " }
              Write-Host ("RUN: {0} {1}" -f $exe, $printed.Trim())

              # Start-Process + redirect로 stdout/stderr를 안전하게 수집하고 ExitCode로 성공/실패를 판정한다.
              $outFile = [System.IO.Path]::GetTempFileName()
              $errFile = [System.IO.Path]::GetTempFileName()
              try {
                $p = Start-Process -FilePath $cmd.Source -ArgumentList $arguments -NoNewWindow -Wait -PassThru `
                  -RedirectStandardOutput $outFile -RedirectStandardError $errFile

                function Write-TextOrClixml([string]$text) {
                  if ([string]::IsNullOrWhiteSpace($text)) { return }

                  # NOTE: this Jenkinsfile is parsed by Groovy; backslashes in regex literals must be escaped (\\s, \\r, \\n).
                  if ($text -match '^\\s*#<\\s*CLIXML') {
                    $xmlText = ($text -replace '^\\s*#<\\s*CLIXML\\s*[\\r\\n]+', '')
                    try {
                      [xml]$x = $xmlText
                      $nodes = $x.SelectNodes('//S')
                      foreach ($n in $nodes) {
                        $t = $n.InnerText -replace '_x000D__x000A_', "`n"
                        foreach ($line in ($t -split "`r?`n")) {
                          if ($line -ne '') { Write-Host $line }
                        }
                      }
                      return
                    } catch {
                      # fall back to raw text
                    }
                  }

                  foreach ($line in ($text -split "`r?`n")) {
                    if ($line -ne '') { Write-Host $line }
                  }
                }

                $stdoutText = [Text.Encoding]::UTF8.GetString(@(Get-Content -LiteralPath $outFile -Encoding Byte -ErrorAction SilentlyContinue))
                $stderrText = [Text.Encoding]::UTF8.GetString(@(Get-Content -LiteralPath $errFile -Encoding Byte -ErrorAction SilentlyContinue))

                Write-TextOrClixml $stdoutText
                Write-TextOrClixml $stderrText

                $exit = [int]$p.ExitCode
                if ($exit -ne 0) {
                  throw "Command failed ($exit): $exe"
                }
              }
              finally {
                Remove-Item -Force -ErrorAction SilentlyContinue $outFile, $errFile
                $ErrorActionPreference = $prevEap
              }
            }

            # ssh 버전 출력(참고용)
            try { & ssh -V 2>&1 | ForEach-Object { Write-Host $_ } } catch { }

            # 1) 원격 디렉토리 생성
            $mk = @"
`$ErrorActionPreference = 'Stop'
`$ProgressPreference = 'SilentlyContinue'
chcp 65001 | Out-Null
[Console]::OutputEncoding = [Text.Encoding]::UTF8
New-Item -ItemType Directory -Force -Path '$remoteTmp' | Out-Null
New-Item -ItemType Directory -Force -Path '$appDir'    | Out-Null
"@
            $mkB64 = [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($mk))

            try {
              # validate key format early (avoid opaque "invalid format")
              $firstLine = (Get-Content -LiteralPath $key -TotalCount 1 -ErrorAction SilentlyContinue)
              if ([string]::IsNullOrWhiteSpace($firstLine)) {
                throw "SSH key file is empty: [$key]"
              }
              if ($firstLine -notmatch '^-+BEGIN .*PRIVATE KEY-+$') {
                throw "SSH key file is not an OpenSSH private key (first line: [$firstLine]). If this is a PuTTY .ppk, convert it to OpenSSH and re-upload the credential."
              }

              Run-External 'ssh' @(
                '-i', $key,
                '-o', 'IdentitiesOnly=yes',
                '-o', 'BatchMode=yes',
                '-o', 'ConnectTimeout=10',
                '-o', 'ConnectionAttempts=1',
                '-o', 'ServerAliveInterval=15',
                '-o', 'ServerAliveCountMax=2',
                '-o', 'LogLevel=ERROR',
                '-o', 'StrictHostKeyChecking=no',
                '-o', 'UserKnownHostsFile=NUL',
                $dest,
                'powershell', '-NoProfile', '-ExecutionPolicy', 'Bypass',
                '-EncodedCommand', $mkB64
              )

              # 2) 아티팩트 업로드
              # upload .env (from Jenkins Secret file credential)
              if ([string]::IsNullOrWhiteSpace($envFile)) { throw "ENV_FILE is empty (check Jenkins file credential id: [$($env:ENV_FILE_CRED_ID)])" }
              if (!(Test-Path -LiteralPath $envFile)) { throw "ENV_FILE not found: [$envFile]" }

              # The file credential is materialized under WORKSPACE@tmp/secretFiles/... and can disappear if workspace cleanup races.
              # Copy it to a stable temp path for the duration of this step.
              $envFileSecure = Join-Path $env:TEMP ("jenkins_envfile_" + ([guid]::NewGuid().ToString('N')) + ".env")
              Copy-Item -Force -LiteralPath $envFile -Destination $envFileSecure
              if (!(Test-Path -LiteralPath $envFileSecure)) { throw "Failed to copy ENV_FILE to temp: [$envFileSecure]" }

              Run-External 'scp' @(
                '-i', $key,
                '-o', 'IdentitiesOnly=yes',
                '-o', 'BatchMode=yes',
                '-o', 'ConnectTimeout=10',
                '-o', 'ConnectionAttempts=1',
                '-o', 'ServerAliveInterval=15',
                '-o', 'ServerAliveCountMax=2',
                '-o', 'LogLevel=ERROR',
                '-o', 'StrictHostKeyChecking=no',
                '-o', 'UserKnownHostsFile=NUL',
                $envFileSecure,
                "${dest}:$remoteEnv"
              )

              Run-External 'scp' @(
                '-i', $key,
                '-o', 'IdentitiesOnly=yes',
                '-o', 'BatchMode=yes',
                '-o', 'ConnectTimeout=10',
                '-o', 'ConnectionAttempts=1',
                '-o', 'ServerAliveInterval=15',
                '-o', 'ServerAliveCountMax=2',
                '-o', 'LogLevel=ERROR',
                '-o', 'StrictHostKeyChecking=no',
                '-o', 'UserKnownHostsFile=NUL',
                $artifact,
                "${dest}:$remoteTgz"
              )

              # 3) 원격 배포 (✅ STOP 먼저 → BACKUP/REPLACE → START)
              $deploy = @"
`$ErrorActionPreference = 'Stop'
`$ProgressPreference = 'SilentlyContinue'
chcp 65001 | Out-Null
[Console]::OutputEncoding = [Text.Encoding]::UTF8

# ---- error trap (원인 로그 확보용) ----
trap {
  Write-Host ("REMOTE ERROR: " + `$_.Exception.Message)
  if (`$_.InvocationInfo) {
    Write-Host ("At: " + `$_.InvocationInfo.PositionMessage)
  }
  exit 1
}

`$tmp    = '$remoteTmp'
`$app    = '$appDir'
`$name   = '$appName'
`$port   = '$port'
`$bundle = Join-Path `$tmp '$artifact'
`$envSrc = Join-Path `$tmp '.env'

Write-Host ("[DEPLOY] tmp=" + `$tmp)
Write-Host ("[DEPLOY] app=" + `$app)
Write-Host ("[DEPLOY] name=" + `$name + " port=" + `$port)
Write-Host ("[DEPLOY] bundle=" + `$bundle)

if (!(Test-Path `$bundle)) { throw ('bundle missing: ' + `$bundle) }
if (!(Test-Path `$envSrc)) { throw ('env missing: ' + `$envSrc) }

# --- ensure pm2 is available (PATH-independent) ---
`$pm2Cmd = Get-Command pm2 -ErrorAction SilentlyContinue
`$pm2Exe = `$null
if (`$pm2Cmd) {
  `$pm2Exe = `$pm2Cmd.Source
} else {
  `$pm2Candidates = @(
    (Join-Path `$env:APPDATA 'npm\\pm2.cmd'),
    ('C:\\Users\\' + `$env:USERNAME + '\\AppData\\Roaming\\npm\\pm2.cmd'),
    'C:\\ProgramData\\npm\\pm2.cmd',
    'C:\\Program Files\\nodejs\\pm2.cmd',
    'C:\\Program Files (x86)\\nodejs\\pm2.cmd'
  )
  foreach (`$c in `$pm2Candidates) { if (Test-Path `$c) { `$pm2Exe = `$c; break } }
}

if (-not `$pm2Exe) {
  `$npmCmd = Get-Command npm -ErrorAction SilentlyContinue
  `$npmExe = `$null
  if (`$npmCmd) {
    `$npmExe = `$npmCmd.Source
  } else {
    `$npmCandidates = @(
      (Join-Path `$env:APPDATA 'npm\\npm.cmd'),
      ('C:\\Users\\' + `$env:USERNAME + '\\AppData\\Roaming\\npm\\npm.cmd'),
      'C:\\ProgramData\\npm\\npm.cmd',
      'C:\\Program Files\\nodejs\\npm.cmd',
      'C:\\Program Files (x86)\\nodejs\\npm.cmd'
    )
    foreach (`$c in `$npmCandidates) { if (Test-Path `$c) { `$npmExe = `$c; break } }
  }

  if (-not `$npmExe) {
    throw "pm2 not found and npm not found on UMPC. Install Node.js (with npm) or preinstall pm2 and ensure PATH is set."
  }

  Write-Host "[DEPLOY] Installing pm2 globally..."
  & `$npmExe i -g pm2

  `$pm2Cmd = Get-Command pm2 -ErrorAction SilentlyContinue
  if (`$pm2Cmd) {
    `$pm2Exe = `$pm2Cmd.Source
  } else {
    foreach (`$c in `$pm2Candidates) { if (Test-Path `$c) { `$pm2Exe = `$c; break } }
  }

  if (-not `$pm2Exe) {
    throw "pm2 installed but executable still not found. Ensure npm global bin is on PATH."
  }
}

Write-Host ("[DEPLOY] pm2=" + `$pm2Exe)

# =========================================================
# 1) STOP FIRST (중요: appDir Move-Item 하기 전에 프로세스부터 내림)
# =========================================================
try {
  Write-Host "[DEPLOY] Stop/Delete pm2 app (best-effort)..."
  try { & `$pm2Exe stop  `$name 2>`$null | Out-Null } catch { }
  try { & `$pm2Exe delete `$name 2>`$null | Out-Null } catch { }
} catch { }

# 포트 점유 PID kill (best-effort)
try {
  `$portNum = [int]`$port
  `$pids = @()

  try {
    `$conns = Get-NetTCPConnection -State Listen -LocalPort `$portNum -ErrorAction SilentlyContinue
    foreach (`$c in (`$conns | Where-Object { `$_.OwningProcess -and `$_.OwningProcess -ne 0 })) {
      `$pids += [int]`$c.OwningProcess
    }
  } catch { }

  if (-not `$pids -or `$pids.Count -eq 0) {
    `$lines = & netstat -ano 2>`$null
    foreach (`$line in (`$lines | Where-Object { `$_ })) {
      `$m = [regex]::Match(`$line, "^(TCP|UDP)\\s+\\S+:`$portNum\\s+\\S+(?:\\s+\\S+)?\\s+(\\d+)\\s*$")
      if (`$m.Success) { `$pids += [int]`$m.Groups[2].Value }
    }
  }

  `$pids = `$pids | Sort-Object -Unique
  if (`$pids -and `$pids.Count -gt 0) {
    Write-Host ("[DEPLOY] Found PID(s) on port {0}: {1}" -f `$portNum, ((`$pids -join ', ')))
    foreach (`$pid in `$pids) {
      try {
        Stop-Process -Id `$pid -Force -ErrorAction Stop
        Write-Host ("[DEPLOY] Killed PID {0}" -f `$pid)
      } catch {
        Write-Host ("[DEPLOY] Failed to kill PID {0}: {1}" -f `$pid, `$_.Exception.Message)
      }
    }
  } else {
    Write-Host ("[DEPLOY] No PID found on port {0}" -f `$portNum)
  }
} catch {
  Write-Host ("[DEPLOY] PID kill skipped: {0}" -f `$_.Exception.Message)
}

# =========================================================
# 2) BACKUP/REPLACE (이제 폴더 잠김 확률 줄어서 Move-Item 성공률 ↑)
# =========================================================
# backup existing env (if present)
`$appEnv  = Join-Path `$app '.env'
if (Test-Path `$appEnv) {
  `$bkEnv = Join-Path `$tmp ('.env.backup.' + (Get-Date -Format yyyyMMdd_HHmmss))
  Copy-Item -Force `$appEnv `$bkEnv
  Write-Host ("[DEPLOY] env backup -> " + `$bkEnv)
}

# appDir backup
if (Test-Path `$app) {
  `$bk = `$app + '.backup.' + (Get-Date -Format yyyyMMdd_HHmmss)
  Write-Host ("[DEPLOY] app backup move -> " + `$bk)
  Move-Item -Force `$app `$bk
}

New-Item -ItemType Directory -Force -Path `$app | Out-Null
Write-Host "[DEPLOY] Extracting bundle..."
tar -xzf `$bundle -C `$app

Write-Host "[DEPLOY] Copying .env..."
Copy-Item -Force `$envSrc (Join-Path `$app '.env')

# =========================================================
# 3) START
# =========================================================
Set-Location `$app
`$env:PORT = `$port
`$env:NODE_ENV = 'production'

Write-Host "[DEPLOY] Starting pm2..."
if (Test-Path '.\\ecosystem.config.cjs') {
  & `$pm2Exe start ecosystem.config.cjs
} else {
  & `$pm2Exe start dist\\main.js --name `$name
}

& `$pm2Exe save
& `$pm2Exe ls --no-color

Write-Host "[DEPLOY] Done."
"@
              $deployB64 = [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($deploy))

              Run-External 'ssh' @(
                '-i', $key,
                '-o', 'IdentitiesOnly=yes',
                '-o', 'BatchMode=yes',
                '-o', 'ConnectTimeout=10',
                '-o', 'ConnectionAttempts=1',
                '-o', 'ServerAliveInterval=15',
                '-o', 'ServerAliveCountMax=2',
                '-o', 'LogLevel=ERROR',
                '-o', 'StrictHostKeyChecking=no',
                '-o', 'UserKnownHostsFile=NUL',
                $dest,
                'powershell', '-NoProfile', '-ExecutionPolicy', 'Bypass',
                '-EncodedCommand', $deployB64
              )
            }
            finally {
              if ($envFileSecure -and (Test-Path -LiteralPath $envFileSecure)) {
                Remove-Item -Force -ErrorAction SilentlyContinue -LiteralPath $envFileSecure
              }
              if ($keySecure -and (Test-Path -LiteralPath $keySecure)) {
                Remove-Item -Force -ErrorAction SilentlyContinue -LiteralPath $keySecure
              }
            }
          '''
        }
      }
    }

    stage('Smoke Check') {
      steps {
        powershell """
          \$ErrorActionPreference = 'Continue'
          chcp 65001 | Out-Null
          [Console]::OutputEncoding = [Text.Encoding]::UTF8

          try {
            \$url = 'http://${env.UMPC_HOST}:${env.APP_PORT}${env.SMOKE_PATH}'
            Write-Host "Smoke check: \$url"
            Invoke-WebRequest \$url -UseBasicParsing -TimeoutSec 10 | Out-Null
            Write-Host 'Smoke check OK'
          } catch {
            Write-Host ("Smoke check failed: " + \$_.Exception.Message)
          }
        """
      }
    }

    stage('Clean Workspace (after)') {
      steps { cleanWs disableDeferredWipeout: true }
    }
  }

  post {
    always  { echo 'Pipeline finished.' }
    success { echo '✅ Deploy succeeded.' }
    failure { echo '❌ Deploy failed.' }
  }
}
